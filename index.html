<html>

<head>
	<title>Starting Code for 1st Project 2017 - with lights and textures</title>
	<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}
	</style>
	<script src="lib/three.min.js"></script>
	<script src="lib/stats.min.js"></script>
	<script src="lib/Coordinates.js"></script>
	<script src="lib/OrbitControls.js"></script>
	<script src="lib/dat.gui.min.js"></script>

	<script src="js/Generator.js"></script>
	<script src="js/HeightDisplacementGenerator.js"></script>
	<script src="js/WaveDisplacementGenerator.js"></script>
	<script src="js/ConstantDisplacementGenerator.js"></script>
	<script src="js/MixGenerator.js"></script>
	<script src="js/Interpolator.js"></script>
	<script src="js/LinearInterpolator.js"></script>
	<script src="js/HeightMap.js"></script>
	<script src="js/HeightMapReader.js"></script>
	<script src="js/Layout.js"></script>
	<script src="js/Grid2DLayout.js"></script>
</head>

<body>

	<style>
		.controls{
			position: absolute;
			bottom: 0px;
			left: 0px;
			width: 100%;
			height: 128;
			padding: 40 0 40 0;
			display: flex;
			flex-direction: row;
			justify-content: center;
		}

		#renderTarget{
			position: absolute;
			top: 0px;
			left: 0px;
			width: 100%;
			height: 100%;
		}
	</style>

	<canvas id='renderTarget'>

	</canvas>

	<script>

		var scene, camera, renderer, controls, stats;
		var grid;
		var props;
		var heightGenerator, waveGeneratorX, waveGeneratorY, seaGenerator;
		var gui;
		var generators;

		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			var renderTarget = document.getElementById('renderTarget');
			renderer = new THREE.WebGLRenderer({ antialias: true, canvas: renderTarget });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0xf0f0f0);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;

			camera.position.set(15, 15, 15);
			camera.lookAt(new THREE.Vector3(0, 0, 0));

			hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
			hemiLight.color.setHSL(0.6, 1, 0.6);
			hemiLight.groundColor.setHSL(0.095, 1, 0.75);
			hemiLight.position.set(0, 500, 0);
			scene.add(hemiLight);

			var spotLight = new THREE.SpotLight(0xffffff, 1);
			spotLight.castShadow = true;
			spotLight.shadow.mapSize.width = 1024;
			spotLight.shadow.mapSize.height = 1024;
			spotLight.shadow.camera.near = 500;
			spotLight.shadow.camera.far = 4000;
			spotLight.shadow.camera.fov = 30;
			spotLight.decay = 2;
			spotLight.position.set(-30, 40, 30);
			spotLight.lookAt(0,0,0);
			scene.add(spotLight);

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild(stats.domElement);

			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.addEventListener('change', Render);

			var heightMapReader = new HeightMapReader();
			//Directions X and Y with respect to the grid
			var directionX = 0 * Math.PI/180;
			var directionY = (directionX+90) * Math.PI/180;
			waveGeneratorX = new WaveDisplacementGenerator(directionX, 0.5, 0.5);
			waveGeneratorY = new WaveDisplacementGenerator(directionY, 0.9, 0.5);
			seaGenerator = new MixGenerator(waveGeneratorX, waveGeneratorY,
				(height1, height2) => {
					return height1+height2;
				});
				

			heightMapReader.readDataFromSrc("textures/heightmap2.png", (map) => {

				grid = new Grid2DLayout(map.width, map.height);
				let geometry = new THREE.BoxGeometry(1, 1, 1);

				grid.addElements((i, j) => {
					let material = new THREE.MeshPhongMaterial({ map: greenTxt });
					var cube = new THREE.Mesh(geometry, material);
					
					return cube;
				});

				grid.layoutElements();
				grid.displayElements();

				heightGenerator = new HeightDisplacementGenerator(map);
				generators.push(heightGenerator);
				updateGenerators();
				
				grid.updateElements((i, j, object) => {
					var yDisplacement = Math.round(heightGenerator.displacementFor(i, j));
					object.position.set(object.position.x, yDisplacement, object.position.z);
				});

				scene.add(grid);

			});

			var Properties = function () {
				this.spacingRows = 1;
				this.spacingColumns = 1;
				this.waveDirection = 45;
				this.factor = 0;
			}

			props = new Properties();
			gui = new dat.GUI();
			gui.add(props, 'spacingRows', 1, 5);
			gui.add(props, 'spacingColumns', 1, 5);
			gui.add(props, 'waveDirection', 0, 90);
			gui.add(props, 'factor', 0, 1).listen();

		}

		var startTime = Date.now();
		var lastGeneratorChange = Date.now();
		var framesElapsed = 0;
		const transitionDuration = 1.0;

		function Update() {
			requestAnimationFrame(Update);

			var deltaTime = Date.now() - startTime;
			var deltaTimeLastChange = Date.now() - lastGeneratorChange;

			if (grid) {

				grid.updateElements((i, j, object) => {
					var value1 = generatorHistory[generatorHistory.length-2].displacementFor(i,j,deltaTime/1000);
					var value2 = generatorHistory[generatorHistory.length-1].displacementFor(i,j,deltaTime/1000);
					var factor = deltaTimeLastChange/500;
					factor = Math.max(Math.min(factor, 1), 0);
					props.factor = factor;
        			value = factor*value2 + (1-factor)*value1;	
					var displacement = value;
					object.position.set(object.position.x, displacement, object.position.z);
					//Change texture based on displacement
					if(framesElapsed%10 != 0) return ;
					var txt = object.material.map;
					if(displacement > -0.5 && displacement < 0.5) txt = greenTxt;
					if(displacement < -0.5) txt = brownTxt;
					if(displacement >  0.5) txt = whiteTxt;
					if(txt != object.material.map){
						object.material.map = txt;
						object.material.needsUpdate = true;
					}else{
						object.material.needsUpdate = false;
					}

			
				});

			}

			framesElapsed++;
			controls.update();
			stats.update();
			Render();
		}

		function Render() {

			renderer.render(scene, camera);
		}
		Start();

		//Textures from https://www.kenney.nl/assets/voxel-pack
		
		var brownTxt = new THREE.TextureLoader().load('./textures/dirt.png');
		var greenTxt = new THREE.TextureLoader().load('./textures/cotton_green.png');
		var whiteTxt = new THREE.TextureLoader().load('./textures/snow.png');

		var flatGenerator = new ConstantDisplacementGenerator(0);
		generators = [waveGeneratorX,
		 waveGeneratorY, 
		 seaGenerator,
		 flatGenerator
		];

		var generatorHistory = [flatGenerator, flatGenerator];

		Update();

	</script>

	<div class='controls' id='controls'>
		<script>
			function changeGeneratorTo(gen){
				generatorHistory.push(gen);
				lastGeneratorChange = Date.now();
			}

			function updateGenerators(){
				var el = document.getElementById('controls')
				while(el.firstChild) el.firstChild.remove();

				var canvases = [];

				generators.forEach((generator) => {
					let canvas = generator.heightMap(128,128).image();
					canvas.id     = "cv";
					canvas.class  = 'controls-button';
					canvas.style.width  = '128px';
					canvas.style.height = '128px';
					canvas.style.zIndex   = 0;
					canvas.style.border   = "1px solid";
					canvas.style.margin  = '10 10 10 10';
					canvas.style.borderRadius = '2px';
					canvas.addEventListener('click', (event) => {
						changeGeneratorTo(generator);
						canvases.forEach((cv) => {
							cv.style.border = '1px solid';
						});
						event.target.style.border = '5px solid #1C6EA4';
					});
					document.getElementById('controls').appendChild(canvas); 
					canvases.push(canvas);
				});
			}

			updateGenerators();
		</script>
	</div>
</body>

</html>